#!/usr/bin/env ruby

# Disable stdout,stderr buffering
STDERR.sync = STDOUT.sync = true

require 'pty'

# spawn the process in a pseudo terminal so colors out outputted
read_io, write_io, pid = PTY.spawn("bash", "-c", ARGV.join(" "))

# we don't need to write to the spawned io
write_io.close

loop do
  fds, = IO.select([read_io], nil, nil, 1)
  if fds
    # should have some data to read
    begin
      print read_io.read_nonblock(10240)
    rescue Errno::EAGAIN, Errno::EWOULDBLOCK
      # do select again
    rescue EOFError, Errno::EIO # EOFError from OSX, EIO is raised by ubuntu
      break
    end
  end
  # if fds are empty, timeout expired - run another iteration
end

# we're done reading, yay!
read_io.close

# just wait until its finally finished closing
Process.waitpid(pid)

# exit with the status code that the process returned
exit $?.exitstatus
